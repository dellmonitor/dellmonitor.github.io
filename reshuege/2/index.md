## Решу ЕГЭ 2-й вариант

**27**  
На каждом 3-м километре кольцевой автодороги с двусторонним движением установлены контейнеры для мусора. Длина кольцевой автодороги равна 3N километров. Нулевой километр и 3N-й километр автодороги находятся в одной точке. Известно количество мусора, которое накапливается ежедневно в каждом из контейнеров. Из каждого пункта мусор вывозит отдельный мусоровоз. Стоимость доставки мусора вычисляется как произведение количества мусора на расстояние от пункта до центра переработки. Центр переработки отходов открыли в одном из пунктов сбора мусора таким образом, чтобы общая стоимость доставки мусора из всех пунктов в этот центр была минимальной.

Определите минимальные расходы на доставку мусора в центр переработки отходов.

<a href="/reshuege/2/27_A.txt" download>Файл A</a>

<a href="/reshuege/2/27_B.txt" download>Файл B</a>

Дано два входных файла (файл A и файл B), каждый из которых в первой строке содержит число N (1 ≤ N ≤ 10 000 000)  — количество пунктов сбора мусора на кольцевой автодороге. В каждой из следующих N строк находится число  — количество мусора в контейнере (все числа натуральные, количество мусора в каждом пункте не превышает 1000). Числа указаны в порядке расположения контейнеров на автомагистрали, начиная с первого километра.

В ответе укажите два числа: сначала значение искомой величины для файла А, затем  — для файла B.

Первая строка входного файла содержит целое число N  — общее количество чисел в наборе. Каждая из следующих N строк содержит одно число.

```python
f = open('27_B.txt')
n = int(f.readline())
garbage = [int(x) for x in f]
linear = garbage[(n // 2) + 1:] + garbage[:(n // 2) + 1] + garbage[(n // 2) + 1:] + garbage[:(n // 2)]

prefixSum = [0] * len(linear)
prefixSum[0] = linear[0]
for i in range(1, len(linear)):
    prefixSum[i] = prefixSum[i - 1] + linear[i]

s = 0
for i in range(1, n // 2):
    s += (garbage[i] + garbage[-i]) * i * 3
s += garbage[n // 2] * (n // 2) * 3

minSum = s
for i in range(n // 2, n + n // 2 - 1):
    s = s + 3 * ((prefixSum[i - 1] - prefixSum[i - n // 2]) - (prefixSum[i + n // 2 - 1] - prefixSum[i - 1]) + linear[i + n // 2])
    minSum = min(minSum, s)
print(minSum)
```
